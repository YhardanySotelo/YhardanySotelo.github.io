<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>iPod Classic - Rueda funcional + scroll</title>
<style>
  /* Reset */
  *{box-sizing:border-box;margin:0;padding:0}
  html,body{height:100%;background:#8d8d8d;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial;color:#fff;-webkit-font-smoothing:antialiased}
  a{color:inherit;text-decoration:none}

  /* iPod container */
  .ipod-wrap{width:420px;max-width:94vw;margin:20px auto;padding:16px;
    background:linear-gradient(180deg,#26292d,#1b1b1b);
    border-radius:28px;box-shadow:0 30px 60px rgba(0,0,0,.6), inset 0 6px 20px rgba(255,255,255,.02);
    border:2px solid rgba(255,255,255,.03)}
  .screen{height:360px;background:#000;border-radius:12px;overflow:hidden;position:relative;
    box-shadow:inset 0 14px 40px rgba(0,0,0,.6), 0 10px 30px rgba(0,0,0,.6);border:1px solid rgba(255,255,255,.02)}
  .header{display:flex;justify-content:space-between;align-items:center;padding:10px 12px;font-weight:600;font-size:13px;color:#e6e6e6;z-index:3}
  .header .title{font-weight:700}
  .header .icons{font-size:12px;color:#bdbdbd}

  /* Layout: split */
  .content{position:relative;height:calc(100% - 42px);display:flex;background:linear-gradient(180deg,#061220 0%, #0b1720 100%)}
  .leftPane{
    width:56%;min-width:140px;padding:14px;display:flex;flex-direction:column;justify-content:center;align-items:center;
    background-size:cover;background-position:center;position:relative;transition:width .36s cubic-bezier(.2,.9,.3,1),opacity .36s;
    border-right:1px solid rgba(255,255,255,.02);
    overflow:hidden;
  }
  /* Keep small hint of left pane (5%) when a page is active */
  .leftPane.hidden{width:5%;opacity:.38;padding:8px 6px;min-width:54px}
  .leftOverlay{position:absolute;inset:0;background:linear-gradient(180deg, rgba(0,0,0,.08), rgba(0,0,0,.75));z-index:1}
  .artistAvatar{width:110px;height:110px;border-radius:10px;object-fit:cover;z-index:2;box-shadow:0 12px 30px rgba(0,0,0,.6)}
  .nowInfo{width:92%;position:relative;z-index:2;margin-top:12px;text-align:center}
  .nowInfo .title{font-weight:800;font-size:16px;color:#fff}
  .nowInfo .artist{font-size:12px;color:#d7e6ef;margin-top:4px}
  .bigProgress{width:92%;height:8px;background:rgba(255,255,255,.06);border-radius:10px;margin-top:10px;overflow:hidden;z-index:2}
  .bigProgress .bar{height:100%;width:0%;background:linear-gradient(90deg,#6ae2ff,#2a9df4);transition:width .12s linear}

  /* rightPane */
  .rightPane{width:44%;padding:12px;display:flex;flex-direction:column;gap:8px;justify-content:flex-start;align-items:flex-start;overflow:auto;transition:width .36s cubic-bezier(.2,.9,.3,1)}
  .rightPane.full{width:95%}

  /* Menu */
  .menu{list-style:none;padding:8px 6px;width:100%;color:#fff;overflow:auto}
  .menu li{padding:10px 12px;border-radius:8px;margin-bottom:8px;background:linear-gradient(180deg,rgba(255,255,255,.02),rgba(0,0,0,.02));
    display:flex;justify-content:space-between;align-items:center;cursor:pointer;transition:transform .12s,background .12s;outline:none}
  .menu li:focus{box-shadow:0 0 0 3px rgba(26,140,255,.12)}
  .menu li:hover{transform:translateX(4px)}
  .menu li.selected{background:linear-gradient(180deg, #7cd3ca, #333232);transform:translateX(6px);color:#012;font-weight:700}
  .menu li .subtitle{font-size:12px;color:rgba(255,255,255,.7)}



  /* Pages */
  .page{display:none;padding:6px;height:100%;overflow:auto}
  .page.active{display:block;animation:fadeIn .24s ease}

  @keyframes fadeIn{from{opacity:0;transform:translateY(6px)}to{opacity:1;transform:none}}

  /* Bio */
  .bio .avatar{width:100%;height:160px;border-radius:10px;object-fit:cover;margin-bottom:12px}
  .bio h3{margin-bottom:8px}
  .bio p{color:#e9eef2;line-height:1.5;font-size:14px}

  /* Music / Now Playing */
  .nowPlaying{display:flex;flex-direction:column;align-items:center;gap:12px;padding:6px;height:100%;justify-content:flex-start}
  .nowPlaying .art{width:60%;max-width:320px;height:auto;border-radius:12px;box-shadow:0 18px 40px rgba(0,0,0,.7)}
  .nowPlaying .meta{width:90%;text-align:center}
  .nowPlaying .meta .song{font-weight:800;font-size:18px}
  .nowPlaying .meta .artist{font-size:13px;color:#cfdde6;margin-top:6px}
  .timeRow{width:90%;Display:flex;justify-content:space-between;font-size:12px;color:#bfcfd6;margin-top:6px}

  .tracks{width:100%;margin-top:8px}
  .track{display:flex;justify-content:space-between;align-items:center;padding:10px;border-radius:8px;background:rgba(255,255,255,.03);margin-bottom:8px;cursor:pointer}
  .track:hover{background:rgba(255,255,255,.05)}
  .track button{background:linear-gradient(180deg,#1db954,#17a44a);border:none;padding:6px 10px;border-radius:6px;color:#022;font-weight:700;cursor:pointer}

  /* Gallery */
  .galleryGrid{display:grid;grid-template-columns:repeat(2,1fr);gap:8px}
  .galleryGrid img{width:100%;height:110px;object-fit:cover;border-radius:8px;cursor:pointer;box-shadow:0 8px 20px rgba(0,0,0,.5);transition:transform .25s}
  .galleryGrid img:hover{transform:scale(1.02)}

  /* Socials */
  .socials{display:flex;flex-direction:column;gap:8px}
  .socials a{padding:10px;border-radius:8px;background:rgba(255,255,255,.03);color:#fff;display:flex;align-items:center;gap:8px;cursor:pointer}

  /* Wheel */
  .controls{display:flex;justify-content:center;padding:14px}
  .wheel{width:240px;height:240px;border-radius:50%;background:radial-gradient(circle at 30% 25%,#2b2b2b 0%,#111 60%);position:relative;box-shadow:0 20px 50px rgba(0,0,0,.7),inset 0 6px 20px rgba(255,255,255,.02)}
  /* ensure actual buttons inside wheel render like the design (remove default button chrome) */
  .wheel button{background:none;border:none;color:inherit;font:inherit;padding:0;margin:0}
  .wheel .center{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:96px;height:96px;border-radius:50%;background:radial-gradient(circle at 30% 25%,#151515 0%,#000 70%);box-shadow:inset 0 6px 18px rgba(255,255,255,.02);display:flex;align-items:center;justify-content:center;font-weight:800;color:#fff;cursor:pointer}
  .wheel .btn-menu{position:absolute;top:14%;left:50%;transform:translateX(-50%);font-size:12px;color:#d9d9d9;cursor:pointer}
  .wheel .btn-prev{position:absolute;left:14%;top:50%;transform:translateY(-50%);font-size:16px;color:#d9d9d9;cursor:pointer}
  .wheel .btn-next{position:absolute;right:14%;top:50%;transform:translateY(-50%);font-size:16px;color:#d9d9d9;cursor:pointer}
  .wheel .btn-play{position:absolute;bottom:14%;left:50%;transform:translateX(-50%);font-size:14px;color:#d9d9d9;cursor:pointer}
  .wheel .tiny{font-size:12px;color:rgba(255,255,255,.75)}


  /* Photo modal inside the ipod screen (not fixed to viewport) */
  .photoModal{position:absolute;left:0;top:0;width:100%;height:100%;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,.65);z-index:60;opacity:0;pointer-events:none;transition:opacity .28s ease}
  .photoModal.open{opacity:1;pointer-events:auto}
  .photoModal .photoFrame{width:92%;height:82%;max-width:760px;max-height:520px;border-radius:12px;overflow:hidden;background:#000;display:flex;flex-direction:column;align-items:center;justify-content:center;position:relative}
  .photoModal img{width:100%;height:100%;object-fit:contain;background:#000}
  .photoModal .thumbs{height:70px;background:linear-gradient(180deg,rgba(255,255,255,.02),rgba(0,0,0,.04));display:flex;gap:8px;padding:8px;overflow:auto}
  .photoModal .thumbs img{height:54px;border-radius:6px;cursor:pointer;opacity:.9;border:2px solid transparent}
  .photoModal .thumbs img.active{border-color:#2aa6ff;opacity:1}
  .photoModal .closeBtn{position:absolute;right:8px;top:8px;padding:6px 8px;border-radius:8px;background:rgba(255,255,255,.03);cursor:pointer}
  .photoModal .navBtn{position:absolute;top:50%;transform:translateY(-50%);padding:8px;border-radius:8px;background:rgba(255,255,255,.03);cursor:pointer}
  .photoModal .navPrev{left:8px}
  .photoModal .navNext{right:8px}

  /* pointer for interactive */
  button, .menu li, .track, .galleryGrid img, .wheel .center, .wheel .btn-menu, .wheel .btn-prev, .wheel .btn-next, .wheel .btn-play, .socials a{cursor:pointer}

  /* scrollbars style (webkit) - apple-like thin translucent */
  .rightPane::-webkit-scrollbar, .menu::-webkit-scrollbar, .page::-webkit-scrollbar, .photoModal .thumbs::-webkit-scrollbar {height:8px;width:8px}
  .rightPane::-webkit-scrollbar-thumb, .menu::-webkit-scrollbar-thumb, .page::-webkit-scrollbar-thumb, .photoModal .thumbs::-webkit-scrollbar-thumb {
    background: rgba(255,255,255,.08); border-radius:8px;
  }
  .rightPane::-webkit-scrollbar-track, .menu::-webkit-scrollbar-track, .page::-webkit-scrollbar-track, .photoModal .thumbs::-webkit-scrollbar-track {
    background: transparent;
  }
  /* firefox scrollbar */
  .rightPane, .menu, .page { scrollbar-width: thin; scrollbar-color: rgba(255,255,255,.08) transparent; }
  .no-transition * {
    transition: none !important;
   }

   /* Asegura que la carátula tenga tamaño inicial aunque no haya cargado la imagen */
    #playingArt {
    width: 60%;
    max-width: 320px;
    aspect-ratio: 1 / 1;   /* cuadrado fijo */
    background: rgba(255,255,255,.05); /* placeholder gris */
    object-fit: cover;
    border-radius: 12px;
    display: block;
    }

    /* Previene que el bloque se colapse antes de que la imagen cargue */
    #nowPlaying {
    min-height: 280px;
    }

 
</style>
</head>
<body>
  <div class="ipod-wrap" role="application" aria-label="iPod Portfolio final">
    <div class="screen" id="screen">
      <div class="header">
        <div class="title" id="headerTitle">9:41 AM • Music</div>
        <div class="icons">5G • ░ ░ ░</div>
      </div>

      <div class="content" id="content">
        <!-- LEFT -->
        <div class="leftPane" id="leftPane">
          <div class="leftOverlay" aria-hidden="true"></div>
          <img id="artistAvatar" class="artistAvatar" src="" alt="Artista">
          <div class="nowInfo" aria-live="polite">
            <div class="title" id="nowTitle">Nombre del Tema</div>
            <div class="artist" id="nowArtist">Nombre del Artista</div>
            <div class="bigProgress" aria-hidden="true"><div class="bar" id="bigBar" style="width:0%"></div></div>
          </div>
        </div>

        <!-- RIGHT -->
        <div class="rightPane" id="rightPane">
          <ul id="menuList" class="menu" role="menu" aria-label="Menu principal"></ul>

          <div id="page-bio" class="page" role="document" aria-hidden="true">
            <h3>Biografía</h3>
            <img src="img/main.webp" alt="Foto artista" class="avatar" style="width:100%;height:160px;object-fit:cover;border-radius:10px;margin-bottom:10px">
            <div class="bio">
              <p><strong>Sebastián Yepes</strong> — Sebastián Yepes Alzate músico colombiano, nacido en la ciudad de Manizales Departamento de Caldas en el eje cafetero Colombiano, el 10 de junio de 1980. Ex-vocalista de la agrupación Sanalejo una de las bandas más importantes de Colombia que logro a lo largo de su carrera una gran cantidad de reconocimientos y premios llevando su música a varios países de Latinoamérica y Estados Unidos.</p>
            </div>
          </div>

          <div id="page-music" class="page" role="document" aria-hidden="true">
            <div class="nowPlaying" id="nowPlaying">
              <img src="" class="art" id="playingArt" alt="Carátula">
              <div class="meta">
                <div class="song" id="playingTitle">Track One</div>
                <div class="artist" id="playingArtist">Nombre del Artista</div>
                <div class="timeRow">
                  <div id="timeCurrent">0:00</div>
                  <div id="timeTotal">0:00</div>
                </div>
                <div class="bigProgress" style="margin-top:8px"><div class="bar" id="mainBar" style="width:0%"></div></div>
              </div>

              <div class="tracks" id="tracksList" aria-label="Lista de pistas"></div>
            </div>
            <audio id="player" preload="metadata"></audio>
          </div>

          <div id="page-photos" class="page" role="document" aria-hidden="true">
            <h3>Fotos</h3>
            <div class="galleryGrid" id="galleryGrid" aria-label="Galería"></div>
          </div>

          <div id="page-social" class="page" role="document" aria-hidden="true">
            <h3>Redes</h3>
            <div class="socials">
              <a href="https://instagram.com" target="_blank" rel="noopener noreferrer">📸 Instagram</a>
              <a href="https://facebook.com" target="_blank" rel="noopener noreferrer">📘 Facebook</a>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Wheel (buttons are real <button> elements) -->
    <div class="controls" aria-hidden="false">
      <div class="wheel" id="wheel" role="group" aria-label="Rueda de control">
        <button class="btn-menu tiny" id="btn-menu" aria-pressed="false">MENU</button>
        <button class="btn-prev tiny" id="btn-prev" aria-label="Anterior">◂◂</button>
        <button class="btn-next tiny" id="btn-next" aria-label="Siguiente">▸▸</button>
        <button class="center" id="btn-select" aria-pressed="false">OK</button>
        <button class="btn-play tiny" id="btn-play" aria-pressed="false">⏯</button>
      </div>
    </div>
  </div>

  <!-- Photo modal INSIDE ipod screen -->
  <div class="photoModal" id="photoModal" aria-hidden="true" role="dialog" aria-label="Foto ampliada">
    <div class="photoFrame" role="document">
      <button class="closeBtn" id="photoClose" aria-label="Cerrar foto">✕</button>
      <button class="navBtn navPrev" id="photoPrev" aria-label="Anterior foto">◂</button>
      <button class="navBtn navNext" id="photoNext" aria-label="Siguiente foto">▸</button>
      <img id="modalImg" alt="Foto ampliada">
      <div class="thumbs" id="photoThumbs" aria-hidden="false"></div>
    </div>
  </div>

<script>
/* ========== Datos ========== */
const DATA = {
  artist: {
    name: 'Sebastián Yepes',
    cover: 'https://picsum.photos/900/900?random=15',
    avatar: 'img/artist.webp'
  },
  menu:[
    { id:'bio', label:'Biografía', subtitle:'Sobre el artista' },
    { id:'music', label:'Música', subtitle:'Pistas & demos' },
    { id:'photos', label:'Fotos', subtitle:'Galería visual' },
    { id:'social', label:'Redes', subtitle:'Instagram / Facebook' }
  ],
  tracks:[
    { title:'No me veré caer', src:'assets/track1.mp3', length:'3:22', art:'img/track1.webp' },
    { title:'Track Two', src:'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-2.mp3', length:'4:02', art:'https://picsum.photos/600/600?random=14' },
    { title:'Ambient Demo', src:'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-3.mp3', length:'2:48', art:'https://picsum.photos/600/600?random=16' }
  ],
  gallery:[
    'https://picsum.photos/900/700?random=31',
    'https://picsum.photos/900/700?random=32',
    'https://picsum.photos/900/700?random=33',
    'https://picsum.photos/900/700?random=34'
  ]
};

/* ========== DOM refs ========== */
const leftPane = document.getElementById('leftPane');
const artistAvatar = document.getElementById('artistAvatar');
const nowTitle = document.getElementById('nowTitle');
const nowArtist = document.getElementById('nowArtist');
const bigBar = document.getElementById('bigBar');

const menuList = document.getElementById('menuList');
const pages = {
  bio: document.getElementById('page-bio'),
  music: document.getElementById('page-music'),
  photos: document.getElementById('page-photos'),
  social: document.getElementById('page-social')
};

const tracksList = document.getElementById('tracksList');
const galleryGrid = document.getElementById('galleryGrid');

const player = document.getElementById('player');
const playingArt = document.getElementById('playingArt');
const playingTitle = document.getElementById('playingTitle');
const playingArtist = document.getElementById('playingArtist');
const mainBar = document.getElementById('mainBar');
const timeCurrent = document.getElementById('timeCurrent');
const timeTotal = document.getElementById('timeTotal');

const btnSelect = document.getElementById('btn-select');
const btnMenu = document.getElementById('btn-menu');
const btnPrev = document.getElementById('btn-prev');
const btnNext = document.getElementById('btn-next');
const btnPlay = document.getElementById('btn-play');

const photoModal = document.getElementById('photoModal');
const modalImg = document.getElementById('modalImg');
const photoThumbs = document.getElementById('photoThumbs');
const photoClose = document.getElementById('photoClose');
const photoPrev = document.getElementById('photoPrev');
const photoNext = document.getElementById('photoNext');

const wheel = document.getElementById('wheel');

let currentMenuIndex = 0;
let inPage = false;
let currentPageId = null;
let currentTrackIndex = 0;
let currentPhotoIndex = 0;

/* ========== MediaSource (MSE) globals ========== */
let currentMSE = {
  mediaSource: null,
  sourceBuffer: null,
  objectUrl: null,
  fetchController: null,
  queue: [],
  isUsingMSE: false
};

/* ========== Util helpers ========== */
function isInsideButton(target){
  return !!target.closest('button');
}
function scrollActivePage(steps, direction){
  // direction: 1 => down, -1 => up
  if(!inPage || !currentPageId) return;
  const active = pages[currentPageId];
  if(!active) return;
  const amount = 80 * steps * direction;
  active.scrollBy({top: amount, behavior: 'smooth'});
}

/* ========== Inicialización UI ========== */
function initArtist(){
  leftPane.style.backgroundImage = `url('${DATA.artist.cover}')`;
  artistAvatar.src = DATA.artist.avatar;
  nowArtist.textContent = DATA.artist.name;
}
function renderMenu(){
  menuList.innerHTML = '';
  DATA.menu.forEach((m,i)=>{
    const li = document.createElement('li');
    li.tabIndex = 0;
    li.dataset.id = m.id;
    li.setAttribute('role','menuitem');
    li.className = i===currentMenuIndex ? 'selected' : '';
    li.innerHTML = `<div><div style="font-size:14px">${m.label}</div><div class="subtitle">${m.subtitle}</div></div><div>›</div>`;
    li.addEventListener('click', ()=> { activateMenuIndex(i); });
    li.addEventListener('keydown', (e)=>{ if(e.key==='Enter') activateMenuIndex(i); });
    menuList.appendChild(li);
  });
}

/* show/hide pages (95%/5% behavior) */
function showPage(id){
  const rightPane = document.getElementById('rightPane');

  if(!id){
    inPage = false;
    currentPageId = null;
    leftPane.classList.remove('hidden');
    rightPane.classList.remove('full');
    Object.values(pages).forEach(p => { 
      p.classList.remove('active'); 
      p.setAttribute('aria-hidden','true'); 
    });
    menuList.style.display = 'block';
    setTimeout(()=> renderMenu(), 160);
    return;
  }

  inPage = true;
  currentPageId = id;

  // 🔧 Forzar sin transición
  document.body.classList.add("no-transition");

  // ocultar menú, expandir/ocultar panes
  menuList.style.display = 'none';
  leftPane.classList.add('hidden');
  rightPane.classList.add('full');

  // Forzar medidas explícitas antes del paint
  rightPane.style.width = "95%";
  leftPane.style.width = "5%";

  // Reflow inmediato
  rightPane.offsetHeight;

  // quitar el hack después de un frame
  requestAnimationFrame(()=>{
    document.body.classList.remove("no-transition");
    rightPane.style.width = ""; // dejar que use la clase full normalmente
    leftPane.style.width = "";  // igual
  });

  Object.values(pages).forEach(p => { 
    p.classList.remove('active'); 
    p.setAttribute('aria-hidden','true'); 
  });
  pages[id].classList.add('active');
  pages[id].setAttribute('aria-hidden','false');

  requestAnimationFrame(()=> {
    pages[id].scrollTop = 0;
    if(id === 'music'){ 
        openMusic();
        requestAnimationFrame(() => {
            document.getElementById('rightPane').style.transform = 'translateZ(0)';
        });
    }
    if(id === 'photos'){ populateGallery(); }
  });
}


function activateMenuIndex(i){
  currentMenuIndex = i;
  renderMenu();
  showPage(DATA.menu[i].id);
}

/* ========== Tracks & Now Playing ========== */
function populateTracks(){
  tracksList.innerHTML = '';
  DATA.tracks.forEach((t,i) => {
    const div = document.createElement('div');
    div.className = 'track';
    div.tabIndex = 0;
    div.innerHTML = `<div><strong>${t.title}</strong><div style="font-size:12px;color:#cfd8dc">${t.length}</div></div><div><button aria-label="Reproducir ${t.title}">Play</button></div>`;
    div.querySelector('button').addEventListener('click', (ev) => { ev.stopPropagation(); playTrack(i); });
    div.addEventListener('click', ()=> playTrack(i));
    div.addEventListener('keydown', (e)=>{ if(e.key==='Enter') playTrack(i); });
    tracksList.appendChild(div);
  });
}

function playTrack(i){
  if(i < 0 || i >= DATA.tracks.length) return;
  // if same track and paused, just resume
  if(i === currentTrackIndex && player.src && player.paused){
    player.play().catch(()=>{});
    return;
  }

  // abort any ongoing MSE/fetch for previous track
  cleanupCurrentMSE();

  currentTrackIndex = i;
  const t = DATA.tracks[i];

  // Try to use MediaSource (chunked) for progressive buffering
  loadTrackWithMSE(t.src).then((usedMSE) => {
    // if MSE was used, the player.src will already be set and playing handled inside loader
    if(!usedMSE){
      // fallback normal loading
      player.src = t.src;
      player.preload = 'auto';
      player.play().catch(()=>{ /* maybe blocked */ });
    }
  }).catch((err)=>{
    console.warn('MSE failed, fallback to normal audio. Err:', err);
    player.src = t.src;
    player.preload = 'auto';
    player.play().catch(()=>{});
  });

  updateNowPlayingUI(t);
}

function updateNowPlayingUI(t){
  playingTitle.textContent = t.title;
  playingArtist.textContent = DATA.artist.name;

  playingArt.src = t.art || DATA.artist.avatar || "img/placeholder.png";

  nowTitle.textContent = t.title;
  nowArtist.textContent = DATA.artist.name;
  leftPane.style.backgroundImage = `url('${t.art || DATA.artist.cover}')`;
}


function openMusic(){
  populateTracks();

  // ⚡ Asegurar que siempre haya una carátula visible la primera vez
  if(!player.src){
    currentTrackIndex = 0;
    const first = DATA.tracks[0];

    player.src = first.src;
    player.preload = "metadata";
    player.pause();

    // Setear carátula inicial (aunque no se haya reproducido aún)
    playingArt.src = first.art || DATA.artist.avatar;
    playingTitle.textContent = first.title;
    playingArtist.textContent = DATA.artist.name;

    nowTitle.textContent = first.title;
    nowArtist.textContent = DATA.artist.name;
    leftPane.style.backgroundImage = `url('${first.art || DATA.artist.cover}')`;
  }
}


/* ========== MediaSource (MSE) implementation ========== */
/*
  - Attempts to stream using MediaSource + Range requests (chunks).
  - If server doesn't accept Range or MSE unsupported -> fallback to normal audio.src
  - Manages aborts if user changes track quickly.
*/
async function loadTrackWithMSE(url){
  // guard: if no MediaSource support, fallback
  if(!('MediaSource' in window)) return false;

  try{
    // probe server with HEAD to see if supports range and get content-length
    const headResp = await fetch(url, { method: 'HEAD' });
    const acceptRanges = headResp.headers.get('accept-ranges') || '';
    const contentLengthHeader = headResp.headers.get('content-length');
    const contentLength = contentLengthHeader ? parseInt(contentLengthHeader, 10) : NaN;
    const supportsRange = acceptRanges.toLowerCase().includes('bytes');

    // only use chunked approach when server supports Range and we know size (not strictly required,
    // but it's more robust)
    if(!supportsRange || isNaN(contentLength)){
      // fallback
      return false;
    }

    // prepare MediaSource
    const mime = 'audio/mpeg'; // common for mp3; adjust if you know different codec
    const mediaSource = new MediaSource();
    currentMSE.mediaSource = mediaSource;
    currentMSE.queue = [];
    currentMSE.fetchController = new AbortController();
    currentMSE.isUsingMSE = true;

    // attach object URL
    const objectUrl = URL.createObjectURL(mediaSource);
    currentMSE.objectUrl = objectUrl;
    player.src = objectUrl;

    // once source open, create SourceBuffer
    await new Promise((resolve, reject) => {
      const onSourceOpen = () => {
        try{
          // MIME may vary; try 'audio/mpeg' first
          const sb = mediaSource.addSourceBuffer(mime);
          currentMSE.sourceBuffer = sb;
          resolve();
        }catch(err){
          // unable to create sourceBuffer for mime -> reject
          reject(err);
        } finally {
          mediaSource.removeEventListener('sourceopen', onSourceOpen);
        }
      };
      mediaSource.addEventListener('sourceopen', onSourceOpen);
      // safety timeout in case sourceopen never fires
      setTimeout(()=> {
        if(mediaSource.readyState !== 'open') {
          reject(new Error('MediaSource open timeout'));
        }
      }, 5000);
    });

    // now fetch in ranges and append
    const chunkSize = 64 * 1024; // 64KB chunks (tuneable)
    let start = 0;
    const total = contentLength;
    const sb = currentMSE.sourceBuffer;

    // append queue helper (ensures we don't append while updating)
    function appendBufferChunk(ab){
      if(!sb) return;
      if(sb.updating){
        currentMSE.queue.push(ab);
      } else {
        try{
          sb.appendBuffer(ab);
        }catch(err){
          console.error('appendBuffer error', err);
          // if error, try to clear queue to avoid blocking
        }
      }
    }
    // when update ends, flush queue
    sb.addEventListener('updateend', ()=>{
      if(currentMSE.queue.length){
        const next = currentMSE.queue.shift();
        try{ sb.appendBuffer(next); } catch(e){ console.error(e); }
      } else {
        // if mediaSource is open and full buffer appended, we can optionally set duration
        // mediaSource.duration = Math.max(mediaSource.duration || 0, player.duration || 0);
      }
    });

    // orchestrate fetch loop
    const controller = currentMSE.fetchController;
    const signal = controller.signal;

    // start playback as soon as we appended first chunk and there's enough data
    let appendedFirstChunk = false;

    while(start < total){
      // if aborted, throw to break
      if(signal.aborted) throw new Error('aborted');

      const end = Math.min(start + chunkSize - 1, total - 1);
      const rangeHeader = `bytes=${start}-${end}`;
      const resp = await fetch(url, { headers: { Range: rangeHeader }, signal });
      if(!resp.ok && resp.status !== 206){
        // server didn't honor the range request
        throw new Error('Range request failed with status ' + resp.status);
      }
      const arrayBuffer = await resp.arrayBuffer();
      appendBufferChunk(arrayBuffer);

      // once we appended first chunk, try to play
      if(!appendedFirstChunk){
        appendedFirstChunk = true;
        // attempt play (may be blocked by browser autoplay policies)
        player.play().catch(()=>{ /* ignore */ });
      }

      start += chunkSize;
    }

    // all chunks fetched -> signal endOfStream when buffer drained
    // wait until sourceBuffer finishes updating and then call endOfStream
    const waitForAllAppended = () => new Promise((resolve) => {
      const check = () => {
        if(!sb.updating && currentMSE.queue.length === 0) resolve();
        else setTimeout(check, 50);
      };
      check();
    });
    await waitForAllAppended();

    // set duration if available
    try{
      if(currentMSE.mediaSource && currentMSE.mediaSource.readyState === 'open'){
        currentMSE.mediaSource.endOfStream();
      }
    }catch(e){ /* ignore */ }

    return true;
  }catch(err){
    // on any error, cleanup MSE and propagate false so caller falls back
    cleanupCurrentMSE();
    console.warn('MSE pipeline error', err);
    return false;
  }
}

function cleanupCurrentMSE(){
  try{
    if(currentMSE.fetchController){
      currentMSE.fetchController.abort();
    }
  }catch(e){}
  try{
    if(currentMSE.sourceBuffer && currentMSE.mediaSource && currentMSE.mediaSource.readyState === 'open'){
      // can't always remove; some browsers restrict removal while updating
      // guard with try/catch
      try{ currentMSE.mediaSource.removeSourceBuffer(currentMSE.sourceBuffer); } catch(e){}
    }
  }catch(e){}
  try{
    if(currentMSE.objectUrl){
      URL.revokeObjectURL(currentMSE.objectUrl);
    }
  }catch(e){}
  // reset state
  currentMSE = { mediaSource: null, sourceBuffer: null, objectUrl: null, fetchController: null, queue: [], isUsingMSE: false };
  // ensure player uses a "normal" src after cleanup (avoid stale objectURL)
  // we do not overwrite player.src here to allow caller to set fallback src
}

/* player events */
player.addEventListener('loadedmetadata', ()=> { if(timeTotal) timeTotal.textContent = formatTime(player.duration || 0); });
player.addEventListener('timeupdate', ()=> {
  if(player.duration && !isNaN(player.duration)){
    const pct = Math.max(0, Math.min(100, (player.currentTime / player.duration) * 100));
    if(mainBar) mainBar.style.width = pct + '%';
    if(bigBar) bigBar.style.width = pct + '%';
    if(timeCurrent) timeCurrent.textContent = formatTime(player.currentTime);
    if(timeTotal) timeTotal.textContent = formatTime(player.duration);
  }
});
player.addEventListener('ended', ()=> {
  const next = (currentTrackIndex + 1) % DATA.tracks.length;
  playTrack(next);
});
function formatTime(s){ if(!s || isNaN(s)) return '0:00'; const min = Math.floor(s/60); const sec = Math.floor(s%60).toString().padStart(2,'0'); return `${min}:${sec}`; }

/* ========== Gallery & Modal ========== */
function populateGallery(){
  galleryGrid.innerHTML = '';
  DATA.gallery.forEach((url, idx)=>{
    const img = document.createElement('img');
    img.src = url; img.alt = 'Foto artista';
    img.tabIndex = 0;
    img.addEventListener('click', ()=> openPhoto(idx));
    img.addEventListener('keydown', (e)=>{ if(e.key==='Enter') openPhoto(idx); });
    galleryGrid.appendChild(img);
  });
}
function openPhoto(index){
  if(index < 0 || index >= DATA.gallery.length) return;
  currentPhotoIndex = index;
  modalImg.src = DATA.gallery[index];
  photoModal.classList.add('open'); photoModal.setAttribute('aria-hidden','false');
  buildPhotoThumbs(); highlightActiveThumb();
}
function closePhoto(){ photoModal.classList.remove('open'); photoModal.setAttribute('aria-hidden','true'); modalImg.src=''; }
function buildPhotoThumbs(){
  photoThumbs.innerHTML = '';
  DATA.gallery.forEach((u,i)=>{
    const t = document.createElement('img'); t.src = u; t.alt='Miniatura'; t.tabIndex=0;
    t.addEventListener('click', ()=> openPhoto(i)); t.addEventListener('keydown', (e)=>{ if(e.key==='Enter') openPhoto(i); });
    if(i===currentPhotoIndex) t.classList.add('active');
    photoThumbs.appendChild(t);
  });
}
function highlightActiveThumb(){ const thumbs = photoThumbs.querySelectorAll('img'); thumbs.forEach((img,i)=> img.classList.toggle('active', i===currentPhotoIndex)); }

photoPrev.addEventListener('click', ()=> { currentPhotoIndex=(currentPhotoIndex-1+DATA.gallery.length)%DATA.gallery.length; modalImg.src = DATA.gallery[currentPhotoIndex]; highlightActiveThumb(); });
photoNext.addEventListener('click', ()=> { currentPhotoIndex=(currentPhotoIndex+1)%DATA.gallery.length; modalImg.src = DATA.gallery[currentPhotoIndex]; highlightActiveThumb(); });
photoClose.addEventListener('click', closePhoto);
photoModal.addEventListener('click', (e)=> { if(e.target === photoModal) closePhoto(); });
modalImg.addEventListener('click', (e)=> e.stopPropagation());

/* ========== Wheel rotation (scroll behavior) ========== */
let tracking=false, lastAngle=null, accumulator=0;
const THRESH = 18; // smaller threshold for more responsive scrolling

function angleFromEvent(e){
  const rect = wheel.getBoundingClientRect();
  const cx = rect.left + rect.width/2;
  const cy = rect.top + rect.height/2;
  const ev = (e.touches && e.touches[0]) ? e.touches[0] : e;
  const x = ev.clientX - cx;
  const y = ev.clientY - cy;
  return Math.atan2(y, x) * 180 / Math.PI;
}

function step(delta){
  accumulator += delta;
  if(Math.abs(accumulator) >= THRESH){
    const steps = Math.floor(Math.abs(accumulator) / THRESH);
    const dir = accumulator > 0 ? 1 : -1; // 1 => clockwise (down), -1 => ccw (up)
    accumulator = 0;

    // Behavior per context
    if(!inPage){
      // menu navigation
      currentMenuIndex = (currentMenuIndex + dir * steps + DATA.menu.length) % DATA.menu.length;
      renderMenu();
    } else {
      // inside a page
      if(currentPageId === 'photos' && photoModal.classList.contains('open')){
        // change photo
        currentPhotoIndex = (currentPhotoIndex + dir * steps + DATA.gallery.length) % DATA.gallery.length;
        modalImg.src = DATA.gallery[currentPhotoIndex];
        highlightActiveThumb();
      } else {
        // scroll the active page
        scrollActivePage(steps, dir);
      }
    }

    if(navigator.vibrate) navigator.vibrate(6);
  }
}

/* Start tracking only when user is not pressing a button (so clicks still work) */
wheel.addEventListener('pointerdown', (e)=>{
  if(isInsideButton(e.target)) return; // ignore pointerdown if clicking a button (so button click works)
  tracking = true;
  lastAngle = angleFromEvent(e);
  try{ wheel.setPointerCapture && wheel.setPointerCapture(e.pointerId); }catch(err){}
});
wheel.addEventListener('pointermove', (e)=>{
  if(!tracking) return;
  const a = angleFromEvent(e);
  let delta = a - lastAngle;
  if(delta > 180) delta -= 360;
  if(delta < -180) delta += 360;
  lastAngle = a;
  step(delta);
});
wheel.addEventListener('pointerup', (e)=>{
  tracking=false; lastAngle=null; accumulator=0;
  try{ wheel.releasePointerCapture && wheel.releasePointerCapture(e.pointerId); }catch(err){}
});
/* Touch fallback */
wheel.addEventListener('touchstart', (e)=>{
  if(isInsideButton(e.target)) return;
  tracking=true; lastAngle = angleFromEvent(e);
}, {passive:false});
wheel.addEventListener('touchmove', (e)=>{
  if(!tracking) return;
  const a = angleFromEvent(e);
  let delta = a - lastAngle;
  if(delta > 180) delta -= 360;
  if(delta < -180) delta += 360;
  lastAngle = a;
  step(delta);
  e.preventDefault();
}, {passive:false});
wheel.addEventListener('touchend', ()=>{ tracking=false; lastAngle=null; accumulator=0; });

/* ========== Wheel buttons (real buttons) ========== */
function safePlayToggle(){
  if(!player.src) { playTrack(0); return; }
  if(player.paused) { player.play().catch(()=>{}); }
  else { player.pause(); }
}

document.getElementById('btn-select').addEventListener('click', ()=>{
  if(!inPage){
    const id = DATA.menu[currentMenuIndex].id;
    showPage(id);
  } else {
    if(currentPageId === 'music') safePlayToggle();
    else if(currentPageId === 'photos') openPhoto(0);
  }
});
document.getElementById('btn-menu').addEventListener('click', ()=>{
  if(inPage) showPage(null);
  else { currentMenuIndex = 0; renderMenu(); }
});
document.getElementById('btn-prev').addEventListener('click', ()=>{
  if(!inPage){
    currentMenuIndex = (currentMenuIndex - 1 + DATA.menu.length) % DATA.menu.length; renderMenu();
  } else if(currentPageId === 'music'){
    const prev = (currentTrackIndex - 1 + DATA.tracks.length) % DATA.tracks.length; playTrack(prev);
  } else if(currentPageId === 'photos'){
    if(photoModal.classList.contains('open')) photoPrev.click(); else openPhoto(DATA.gallery.length - 1);
  } else {
    // scroll up small
    if(currentPageId) pages[currentPageId].scrollBy({top:-80, behavior:'smooth'});
  }
});
document.getElementById('btn-next').addEventListener('click', ()=>{
  if(!inPage){
    currentMenuIndex = (currentMenuIndex + 1) % DATA.menu.length; renderMenu();
  } else if(currentPageId === 'music'){
    const next = (currentTrackIndex + 1) % DATA.tracks.length; playTrack(next);
  } else if(currentPageId === 'photos'){
    if(photoModal.classList.contains('open')) photoNext.click(); else openPhoto(0);
  } else {
    if(currentPageId) pages[currentPageId].scrollBy({top:80, behavior:'smooth'});
  }
});
document.getElementById('btn-play').addEventListener('click', ()=> safePlayToggle());

/* ========== Keyboard support & accessibility ========== */
window.addEventListener('keydown', (e)=>{
  if(e.key === 'ArrowUp'){ currentMenuIndex = (currentMenuIndex - 1 + DATA.menu.length) % DATA.menu.length; renderMenu(); }
  if(e.key === 'ArrowDown'){ currentMenuIndex = (currentMenuIndex + 1) % DATA.menu.length; renderMenu(); }
  if(e.key === 'Enter'){ document.getElementById('btn-select').click(); }
  if(e.key === 'Escape'){ document.getElementById('btn-menu').click(); if(photoModal.classList.contains('open')) closePhoto(); }
});

/* Live region for a11y */
const live = document.createElement('div');
live.setAttribute('aria-live','polite'); live.style.position='absolute'; live.style.left='-9999px';
document.body.appendChild(live);
const mo = new MutationObserver(()=> live.textContent = DATA.menu[currentMenuIndex].label + ' seleccionado');
mo.observe(menuList,{childList:true,subtree:true});

/* ========== Initialize ========== */
function init(){
  initArtist();
  renderMenu();
  populateTracks();

  currentTrackIndex = 0;
  const first = DATA.tracks[0];

  // ⚡ Configurar el primer track desde el inicio
  player.src = first.src;
  player.preload = "metadata";
  player.pause();

  // Mostrar carátula y textos desde el arranque
  updateNowPlayingUI(first);

  if(bigBar) bigBar.style.width = "0%";
}

init();

/* prevent dragging images on desktop */
document.addEventListener('dragstart', (e)=>{ if(e.target.tagName === 'IMG') e.preventDefault(); });

</script>
</body>
</html>
